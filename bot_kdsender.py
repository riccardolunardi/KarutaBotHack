import asyncio, discord, random, sys, time, traceback
import logging, logging.handlers
from logging.handlers import RotatingFileHandler
from discord.ext import commands

import json, subprocess, os

with open("options.json","r") as options:
    user_data = json.load(options)

test = False
interval = 30/len(user_data["guilds"]["premium"][0]["users"])

class Bot(discord.ext.commands.Bot):

    def __init__(self, master, kdrop, ktrade, kspam, tk, turn, bot_name, **kwargs):
        super().__init__(**kwargs)
        self.kdrop_channel = kdrop
        self.ktrade_channel = ktrade
        self.spam_channel = kspam
        self.id_karuta = 646937666251915264
        self.master = master
        self.token = tk
        self.turn = turn * (interval * 60 + 10)
        self.first_cycle = True
        self.log_file = f"logs/{bot_name}.log"

        if test:
            self.first_cycle = False

        logging.root.setLevel(logging.NOTSET)
        log_formatter = logging.Formatter("%(asctime)s - %(message)s",'%d-%b-%y %H:%M:%S')
        my_handler = RotatingFileHandler(self.log_file, mode='a', maxBytes=30*1024*1024, backupCount=3, encoding=None, delay=0)
        my_handler.setFormatter(log_formatter)
        my_handler.setLevel(logging.DEBUG)
        logger = logging.getLogger(bot_name)
        logger.addHandler(my_handler)

        self.logger = logger
    
    async def on_error(self, event, *args, **kwargs):
        (typ, value, tb) = sys.exc_info()
        string_to_log = f"Unexpected event: {event} -> {typ} - Generated by: {args[0]} - Error: {value} - Traceback: "
        self.logger.debug(string_to_log)
        
        with open(self.log_file,"a") as f:
            traceback.print_tb(tb,file=f)
            traceback.print_tb(tb)

        print(event, ":", value)

    async def on_command_error(self, ctx, exception):
        # This prevents any commands with local handlers being handled here in on_command_error.
        print("Errore: ")        
        
        if hasattr(ctx.command, 'on_error'):
            return

        # This prevents any cogs with an overwritten cog_command_error being handled here.
        cog = ctx.cog
        if cog:
            if cog._get_overridden_method(cog.cog_command_error) is not None:
                return

        error = getattr(exception, 'original', exception)

        if not isinstance(error, commands.CommandError):
            raise exception.original
        if isinstance(error, commands.CommandNotFound):
            self.logger.debug("Command not found: "+ctx.message.content+" - "+str(exception))
            print("Command not found: "+ctx.message.content+" - "+str(exception))

    async def loop_unhandled_exception(self, exception, name):
        print(exception)
        await self.on_error(exception, name)


bots = []
for version, guild in user_data["guilds"].items():
    for server in guild:
        need_master = 1
        for i, user in enumerate(server["users"]):
            if i == 2 and test:
                break

            time.sleep(0.5)

            bot = Bot(master = need_master,  kdrop = server["drops"], ktrade = server["trades"], kspam = server["spam"], tk = user["token"], turn = i, bot_name = user["name"], command_prefix=["Soda ","soda "], self_bot=False)
            
            # Cogs da importare
            initial_extensions = ['cogs.main_events', 'cogs.drop', 'cogs.events', 'cogs.burn', 'cogs.grab', 'cogs.trade_random']
            #initial_extensions = [] #TEST

            if test:
                initial_extensions = ['cogs.main_events', 'cogs.trade_random'] #TEST

            if bot.master == 1:
                initial_extensions.append("cogs.trade_master")
                print("Sono master")
            else:
                initial_extensions.append("cogs.trade_slave")
                print("Sono slave")

            #initial_extensions = ['cogs.main_events', 'cogs.grab'] #TEST
            
            for extension in initial_extensions:
                try:
                    bot.load_extension(extension)
                except Exception as e:
                    print(f'Failed to load extension {extension}', file=sys.stderr)
                    traceback.print_exc()
            
            if need_master:
                need_master = server["users"][0]["name"]

            bots.append(bot)

loop = asyncio.get_event_loop()

for b in bots:
    loop.create_task(b.start(b.token))

try:
    loop.run_forever()
finally:
    loop.stop()